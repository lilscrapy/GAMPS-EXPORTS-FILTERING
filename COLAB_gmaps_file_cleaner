
# To use this script in Google Colab:
# 1. In a Colab notebook cell, run the command above to install the necessary librarie
#
# 2. Upload this script ('maps_category_filter.py') to your Colab environment.
#
# 3. Run the script from a Colab cell:
#    !python maps_category_filter.py
#
# 4. The script will guide you to upload your file, enter your API key, and define your search criteria.

import pandas as pd
import asyncio
import aiohttp
from tqdm import tqdm
import io
from google.colab import files
import nest_asyncio
from google.colab import userdata
import time
from IPython.display import display, HTML
import ipywidgets as widgets

nest_asyncio.apply()

CATEGORY_COL = "category"  # Make sure this is the correct column name

# === GPT PROMPT ===
def build_prompt(category, target_keyword):
    return [
        {"role": "user", "content": f"Is the following business category likely related to a **{target_keyword}**? Only reply 'yes' or 'no'.\n\nCategory: {category}"}
    ]

# === ASYNC GPT CALL ===
async def classify_category(session, semaphore, category, api_key, target_keyword):
    url = "https://api.openai.com/v1/chat/completions"
    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json"
    }
    payload = {
        "model": "gpt-4",
        "messages": build_prompt(category, target_keyword),
        "temperature": 0
    }

    async with semaphore:
        try:
            async with session.post(url, json=payload, headers=headers, timeout=30) as resp:
                data = await resp.json()
                if "choices" not in data or not data["choices"]:
                    error_msg = data.get("error", {}).get("message", "Unknown API error")
                    print(f"‚ö†Ô∏è  API Error: {error_msg} for category: {category}")
                    return category, False, "error_api"
                reply = data["choices"][0]["message"]["content"].strip().lower()
                is_relevant = "yes" in reply
                return category, is_relevant, reply
        except Exception as e:
            print(f"‚ö†Ô∏è  Error: {e} for category: {category}")
            return category, False, "error"

# === CHECKBOX CATEGORY SELECTION ===
async def select_categories_with_checkboxes(categories):
    """
    Allows user to select categories via checkboxes using ipywidgets
    """
    print(f"\nüìã {len(categories)} categories have been marked as relevant by AI.")
    print("Select the categories you want to keep:")

    # Create checkboxes using ipywidgets
    checkboxes = {}
    for category in categories:
        checkboxes[category] = widgets.Checkbox(
            value=True,  # Default to selected
            description=category,
            style={'description_width': 'initial'}
        )

    # Create buttons
    select_all_btn = widgets.Button(description="Select All")
    deselect_all_btn = widgets.Button(description="Deselect All")
    confirm_btn = widgets.Button(description="Confirm Selection", button_style='success')

    # Create output widget to display results
    output_widget = widgets.Output()

    # Function to handle button clicks
    def on_select_all_click(b):
        for checkbox in checkboxes.values():
            checkbox.value = True

    def on_deselect_all_click(b):
        for checkbox in checkboxes.values():
            checkbox.value = False

    def on_confirm_click(b):
        selected = [cat for cat, checkbox in checkboxes.items() if checkbox.value]
        with output_widget:
            output_widget.clear_output()
            print(f"\n‚úÖ Manual filtering applied: {len(selected)} categories selected.")
        # Store result in a way that the function can access
        on_confirm_click.selected_categories = selected
        on_confirm_click.confirmed = True

    # Attach button handlers
    select_all_btn.on_click(on_select_all_click)
    deselect_all_btn.on_click(on_deselect_all_click)
    confirm_btn.on_click(on_confirm_click)

    # Create layout
    button_layout = widgets.HBox([select_all_btn, deselect_all_btn, confirm_btn])

    # Create scrollable area for checkboxes
    checkbox_list = widgets.VBox(list(checkboxes.values()))
    scroll_area = widgets.VBox([
        widgets.HTML(value=f"<h4>Categories ({len(categories)} found):</h4>"),
        button_layout,
        widgets.HTML(value="<div style='max-height: 300px; overflow-y: auto;'>"),
        checkbox_list,
        widgets.HTML(value="</div>"),
        output_widget
    ])

    # Display the interface
    display(scroll_area)

    # Wait for confirmation using a non-blocking approach
    print("\n‚è≥ Please select your categories above and click 'Confirm Selection'.")
    print("After clicking confirm, the script will continue automatically.")

    # Initialize the 'confirmed' flag. This is important if the function runs multiple times.
    on_confirm_click.confirmed = False

    max_wait_time = 300  # 5 minutes max wait
    start_time = time.time()
    
    while not on_confirm_click.confirmed:
        if time.time() - start_time > max_wait_time:
            print("\n‚ö†Ô∏è Timeout waiting for selection. Using all categories.")
            scroll_area.close()  # Hide the widgets on timeout
            return categories
        await asyncio.sleep(0.1)  # Non-blocking sleep that allows UI events to be processed

    scroll_area.close() # Hide the widgets after selection is confirmed

    selected_categories = on_confirm_click.selected_categories
    # The confirmation message is now printed inside on_confirm_click

    return selected_categories

# === DRIVER FUNCTION ===
async def process_and_export(df, api_key, input_filename):
    # Demander le nom du fichier final √† l'utilisateur d√®s le d√©but
    output_filename = input("\nüíæ Entrez le nom du fichier de sortie (ex: resultat.csv) : ").strip()
    if not output_filename:
        output_filename = f"classified_results_{input_filename}"
    # Forcer l'extension .csv si elle n'est pas pr√©sente
    if not output_filename.lower().endswith('.csv'):
        output_filename += '.csv'

    initial_row_count = len(df)
    print(f"üìÑ File contains {initial_row_count} rows.")
    rows_after_filtering = initial_row_count

    # --- Optional Filtering ---
    filtered_df = df.copy()
    if 'rating' in filtered_df.columns and 'ratingCount' in filtered_df.columns:
        try:
            temp_df = filtered_df.copy()
            while True:
                rating_input = input("  - Enter minimum rating (e.g., 4.0, leave blank for none): ")
                rating_count_input = input("  - Enter minimum rating count (e.g., 50, leave blank for none): ")

                temp_df = filtered_df.copy()
                if rating_input:
                    min_rating = float(rating_input)
                    temp_df = temp_df[pd.to_numeric(temp_df['rating'], errors='coerce').fillna(0) >= min_rating]
                if rating_count_input:
                    min_rating_count = int(rating_count_input)
                    temp_df = temp_df[pd.to_numeric(temp_df['ratingCount'], errors='coerce').fillna(0) >= min_rating_count]

                print(f"‚û°Ô∏è {len(temp_df)} rows remaining with these filters.")

                confirm = input("Do you want to keep these filters? (yes to confirm, no to try again): ").lower().strip()
                if confirm == 'yes':
                    filtered_df = temp_df
                    break

            rows_after_filtering = len(filtered_df)

        except ValueError:
            print("‚ö†Ô∏è Invalid number format. Skipping rating/count filters.")
        except Exception as e:
            print(f"‚ö†Ô∏è An error occurred during filtering: {e}")

    rows_removed_by_filter = initial_row_count - rows_after_filtering

    # === MANUAL SELECTION QUESTION (moved before search criteria) ===
    manual_selection = input("\nüîß Do you want to manually select categories to keep? (yes/no): ").strip().lower()
    enable_manual_selection = manual_selection == 'yes'

    target_keyword = input("\nüéØ Please enter the search criteria (e.g., medical weight loss clinic): ")
    if not target_keyword:
        print("‚ùå Search criteria not provided. Halting script.")
        return

    unique_categories = filtered_df[CATEGORY_COL].dropna().unique()
    print(f"\nüîç Processing {len(unique_categories)} unique categories from {rows_after_filtering} rows.")

    results = {}
    semaphore = asyncio.Semaphore(50)  # Reduced from 400 to 50 to respect TPM limits

    async with aiohttp.ClientSession() as session:
        tasks = [classify_category(session, semaphore, cat, api_key, target_keyword) for cat in unique_categories]
        for f in tqdm(asyncio.as_completed(tasks), total=len(tasks), desc="Classifying"):
            cat, is_relevant, reply = await f
            results[cat] = is_relevant
            # label = "‚úÖ RELEVANT" if is_relevant else "‚ùå NOT RELEVANT"
            # print(f"{label}: {cat} ‚Üí GPT: '{reply}'")

    # Merge results and filter to keep only TRUE values
    result_col_name = f"is_{target_keyword.replace(' ', '_').lower()}"
    filtered_df[result_col_name] = filtered_df[CATEGORY_COL].map(results)

    relevant_df = filtered_df[filtered_df[result_col_name] == True]

    # Get categories kept in the final file
    kept_categories = relevant_df[CATEGORY_COL].dropna().unique()
    
    # === MANUAL SELECTION WITH CHECKBOXES ===
    if len(kept_categories) > 0 and enable_manual_selection:
        # Convert numpy array to list
        kept_categories_list = kept_categories.tolist()
        selected_categories = await select_categories_with_checkboxes(kept_categories_list)
        
        # Check if the user made a selection that is different from keeping all
        if selected_categories and len(selected_categories) < len(kept_categories_list):
            # Filter DataFrame to keep only selected categories
            relevant_df = relevant_df[relevant_df[CATEGORY_COL].isin(selected_categories)]
        elif not selected_categories or len(selected_categories) == 0:
            print("\n‚ùå No categories selected. No data will be exported.")
            relevant_df = pd.DataFrame(columns=filtered_df.columns)  # Empty DataFrame
            
    elif len(kept_categories) > 0:
        print("\n‚úÖ Using all categories marked as relevant by AI.")
    else:
        print("\n‚ö†Ô∏è No categories were marked as relevant by AI.")

    relevant_df.to_csv(output_filename, index=False)

    # --- Final Stats ---
    final_relevant_rows = len(relevant_df)
    print("\nüìä --- Final Statistics ---")
    print(f"Initial rows in file: {initial_row_count}")
    if rows_removed_by_filter > 0:
        print(f"Rows removed by rating/count filter: {rows_removed_by_filter}")
    print(f"Rows removed by category filter: {rows_after_filtering - final_relevant_rows}")
    print(f"Unique categories processed: {len(unique_categories)}")
    print(f"Rows kept after classification ('TRUE'): {final_relevant_rows}")
    print(f"Total rows removed from original file: {initial_row_count - final_relevant_rows}")
    print("--------------------------\n")

    print(f"‚úÖ DONE. The results file '{output_filename}' with {final_relevant_rows} relevant rows has been created.")
    print(f"‚¨áÔ∏è T√©l√©chargement automatique du fichier dans quelques secondes...")
    time.sleep(2)  # Pause pour s'assurer que le fichier est bien √©crit
    files.download(output_filename)
    print("Si le t√©l√©chargement ne d√©marre pas, vous pouvez le relancer manuellement depuis la barre lat√©rale de Colab.")

async def main():
    # R√©cup√©rer la cl√© API depuis le secret 'openAI' si disponible, sinon demander √† l'utilisateur.
    api_key = userdata.get('openAI')
    if not api_key:
        api_key = input("üîë Please enter your OpenAI API key: ")
    if not api_key:
        print("‚ùå API key not provided. Halting script.")
        return

    print("\nüì§ Please choose the CSV file to analyze:")
    uploaded = files.upload()
    if not uploaded:
        print("‚ùå No file selected. Halting script.")
        return

    input_filename = next(iter(uploaded))
    print(f"üìÑ File '{input_filename}' uploaded successfully.")

    try:
        df = pd.read_csv(io.BytesIO(uploaded[input_filename]))
        if CATEGORY_COL not in df.columns:
            print(f"‚ùå Error: Column '{CATEGORY_COL}' not found in the file. Please check the column name.")
            return
    except Exception as e:
        print(f"‚ùå Error reading the CSV file: {e}")
        return

    while True:
        await process_and_export(df, api_key, input_filename)
        again = input("\nüîÅ Voulez-vous refaire un autre fichier √† partir du m√™me CSV ? (oui/non) : ").strip().lower()
        if again != 'oui':
            print("üëã Fin du script.")
            break

# === RUN ===
if __name__ == "__main__":
    asyncio.run(main())